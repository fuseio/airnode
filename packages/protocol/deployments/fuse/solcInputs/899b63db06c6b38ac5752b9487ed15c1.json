{
  "language": "Solidity",
  "sources": {
    "contracts/Airnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./interfaces/IAirnode.sol\";\r\nimport \"./EndpointStore.sol\";\r\nimport \"./TemplateStore.sol\";\r\n\r\n\r\n/// @title The contract used to make and fulfill requests\r\n/// @notice Clients use this contract to make requests that follow a\r\n/// request-response scheme. In addition, it inherits from contracts that keep\r\n/// records of providers, requesters, endpoints, etc.\r\ncontract Airnode is EndpointStore, TemplateStore, IAirnode {\r\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\r\n    mapping(bytes32 => bool) public requestWithIdHasFailed;\r\n\r\n\r\n    /// @notice Called by the client to make a regular request. A regular\r\n    /// request refers to a template for the requester-agnostic parameters, but\r\n    /// requires the client to provide the requester-specific parameters.\r\n    /// @dev This is the recommended way of making a request in most cases. Use\r\n    /// makeShortRequest() if gas efficiency is critical.\r\n    /// @param templateId Template ID from TemplateStore\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet that is requested to fulfill\r\n    /// the request\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\r\n    /// determined at runtime, unlike the static parameters stored in the\r\n    /// template)\r\n    /// @return requestId Request ID\r\n    function makeRequest(\r\n        bytes32 templateId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        override\r\n        returns (bytes32 requestId)\r\n    {\r\n        require(\r\n            requesterIndexToClientAddressToEndorsementStatus[requesterIndex][msg.sender],\r\n            \"Client not endorsed by requester\"\r\n            );\r\n        uint256 clientNoRequests = clientAddressToNoRequests[msg.sender];\r\n        requestId = keccak256(abi.encode(\r\n            clientNoRequests,\r\n            msg.sender,\r\n            templateId,\r\n            parameters\r\n            ));\r\n        bytes32 providerId = templates[templateId].providerId;\r\n        requestIdToFulfillmentParameters[requestId] = keccak256(abi.encodePacked(\r\n            providerId,\r\n            designatedWallet,\r\n            fulfillAddress,\r\n            fulfillFunctionId\r\n            ));\r\n        emit ClientRequestCreated(\r\n            providerId,\r\n            requestId,\r\n            clientNoRequests,\r\n            msg.sender,\r\n            templateId,\r\n            requesterIndex,\r\n            designatedWallet,\r\n            fulfillAddress,\r\n            fulfillFunctionId,\r\n            parameters\r\n        );\r\n        clientAddressToNoRequests[msg.sender]++;\r\n    }\r\n\r\n    /// @notice Called by the requester to make a short request. A short\r\n    /// request refers to a template, which the provider will use to get both\r\n    /// requester-agnostic and requester-specific parameters\r\n    /// @dev Use this if gas efficiency is critical\r\n    /// @param templateId Template ID from TemplateStore\r\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\r\n    /// determined at runtime, unlike the static parameters stored in the\r\n    /// template)\r\n    /// @return requestId Request ID\r\n    function makeShortRequest(\r\n        bytes32 templateId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        override\r\n        returns (bytes32 requestId)\r\n    {\r\n        Template storage template = templates[templateId];\r\n        require(\r\n            requesterIndexToClientAddressToEndorsementStatus[template.requesterIndex][msg.sender],\r\n            \"Client not endorsed by requester\"\r\n            );\r\n        uint256 clientNoRequests = clientAddressToNoRequests[msg.sender];\r\n        requestId = keccak256(abi.encode(\r\n            clientNoRequests,\r\n            msg.sender,\r\n            templateId,\r\n            parameters\r\n            ));\r\n        requestIdToFulfillmentParameters[requestId] = keccak256(abi.encodePacked(\r\n            template.providerId,\r\n            template.designatedWallet,\r\n            template.fulfillAddress,\r\n            template.fulfillFunctionId\r\n            ));\r\n        emit ClientShortRequestCreated(\r\n            templates[templateId].providerId,\r\n            requestId,\r\n            clientNoRequests,\r\n            msg.sender,\r\n            templateId,\r\n            parameters\r\n        );\r\n        clientAddressToNoRequests[msg.sender]++;\r\n    }\r\n\r\n    /// @notice Called by the requester to make a full request. A full request\r\n    /// does not refer to a template, meaning that it passes all the parameters\r\n    /// in the request. It does not require a template to be created\r\n    /// beforehand, which provides extra flexibility compared to makeRequest()\r\n    /// and makeShortRequest().\r\n    /// @dev This is the least gas efficient way of making a request. Do not\r\n    /// use it unless you have a good reason.\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param endpointId Endpoint ID from EndpointStore\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet that is requested to fulfill\r\n    /// the request\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @param parameters All request parameters\r\n    /// @return requestId Request ID\r\n    function makeFullRequest(\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        override\r\n        returns (bytes32 requestId)\r\n    {\r\n        require(\r\n            requesterIndexToClientAddressToEndorsementStatus[requesterIndex][msg.sender],\r\n            \"Client not endorsed by requester\"\r\n            );\r\n        uint256 clientNoRequests = clientAddressToNoRequests[msg.sender];\r\n        requestId = keccak256(abi.encode(\r\n            clientNoRequests,\r\n            msg.sender,\r\n            endpointId,\r\n            parameters\r\n            ));\r\n        requestIdToFulfillmentParameters[requestId] = keccak256(abi.encodePacked(\r\n            providerId,\r\n            designatedWallet,\r\n            fulfillAddress,\r\n            fulfillFunctionId\r\n            ));\r\n        emit ClientFullRequestCreated(\r\n            providerId,\r\n            requestId,\r\n            clientNoRequests,\r\n            msg.sender,\r\n            endpointId,\r\n            requesterIndex,\r\n            designatedWallet,\r\n            fulfillAddress,\r\n            fulfillFunctionId,\r\n            parameters\r\n        );\r\n        clientAddressToNoRequests[msg.sender]++;\r\n    }\r\n\r\n    /// @notice Called by the oracle node to fulfill individual requests\r\n    /// (including regular, short and full requests)\r\n    /// @param requestId Request ID\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param statusCode Status code of the fulfillment\r\n    /// @param data Fulfillment data\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @return callSuccess If the fulfillment call succeeded\r\n    /// @return callData Data returned by the fulfillment call (if there is\r\n    /// any)\r\n    function fulfill(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        uint256 statusCode,\r\n        bytes32 data,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId\r\n        )\r\n        external\r\n        override\r\n        onlyCorrectFulfillmentParameters(\r\n            requestId,\r\n            providerId,\r\n            fulfillAddress,\r\n            fulfillFunctionId\r\n            )\r\n        returns(\r\n            bool callSuccess,\r\n            bytes memory callData\r\n        )\r\n    {\r\n        delete requestIdToFulfillmentParameters[requestId];\r\n        emit ClientRequestFulfilled(\r\n            providerId,\r\n            requestId,\r\n            statusCode,\r\n            data\r\n            );\r\n        (callSuccess, callData) = fulfillAddress.call(  // solhint-disable-line\r\n            abi.encodeWithSelector(fulfillFunctionId, requestId, statusCode, data)\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the oracle node to fulfill individual requests\r\n    /// (including regular, short and full requests) with a bytes type response\r\n    /// @dev The oracle uses this method to fulfill if the requester has\r\n    /// specifically asked for a bytes type response\r\n    /// @param requestId Request ID\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param statusCode Status code of the fulfillment\r\n    /// @param data Fulfillment data of type bytes\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @return callSuccess If the fulfillment call succeeded\r\n    /// @return callData Data returned by the fulfillment call (if there is\r\n    /// any)\r\n    function fulfillBytes(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        uint256 statusCode,\r\n        bytes calldata data,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId\r\n        )\r\n        external\r\n        override\r\n        onlyCorrectFulfillmentParameters(\r\n            requestId,\r\n            providerId,\r\n            fulfillAddress,\r\n            fulfillFunctionId\r\n            )\r\n        returns(\r\n            bool callSuccess,\r\n            bytes memory callData\r\n        )\r\n    {\r\n        delete requestIdToFulfillmentParameters[requestId];\r\n        emit ClientRequestFulfilledWithBytes(\r\n            providerId,\r\n            requestId,\r\n            statusCode,\r\n            data\r\n            );\r\n        (callSuccess, callData) = fulfillAddress.call(  // solhint-disable-line\r\n            abi.encodeWithSelector(fulfillFunctionId, requestId, statusCode, data)\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the oracle node if a request cannot be fulfilled\r\n    /// @dev The oracle should fall back to this if a request cannot be\r\n    /// fulfilled because fulfill() reverts\r\n    /// @param requestId Request ID\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    function fail(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId\r\n        )\r\n        external\r\n        override\r\n        onlyCorrectFulfillmentParameters(\r\n            requestId,\r\n            providerId,\r\n            fulfillAddress,\r\n            fulfillFunctionId\r\n            )\r\n    {\r\n        delete requestIdToFulfillmentParameters[requestId];\r\n        // Failure is recorded so that it can be checked externally\r\n        requestWithIdHasFailed[requestId] = true;\r\n        emit ClientRequestFailed(\r\n            providerId,\r\n            requestId\r\n            );\r\n    }\r\n\r\n    /// @dev Reverts unless the incoming fulfillment parameters do not match\r\n    /// the ones provided in the request\r\n    /// @param requestId Request ID\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    modifier onlyCorrectFulfillmentParameters(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId\r\n        )\r\n    {\r\n        bytes32 incomingFulfillmentParameters = keccak256(abi.encodePacked(\r\n            providerId,\r\n            msg.sender,\r\n            fulfillAddress,\r\n            fulfillFunctionId\r\n            ));\r\n        require(\r\n            incomingFulfillmentParameters == requestIdToFulfillmentParameters[requestId],\r\n            \"Incorrect fulfillment parameters\"\r\n            );\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IEndpointStore.sol\";\r\nimport \"./ITemplateStore.sol\";\r\n\r\n\r\ninterface IAirnode is IEndpointStore, ITemplateStore {\r\n    event ClientRequestCreated(\r\n        bytes32 indexed providerId,\r\n        bytes32 indexed requestId,\r\n        uint256 noRequests,\r\n        address clientAddress,\r\n        bytes32 templateId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes parameters\r\n        );\r\n\r\n    event ClientShortRequestCreated(\r\n        bytes32 indexed providerId,\r\n        bytes32 indexed requestId,\r\n        uint256 noRequests,\r\n        address clientAddress,\r\n        bytes32 templateId,\r\n        bytes parameters\r\n        );\r\n\r\n    event ClientFullRequestCreated(\r\n        bytes32 indexed providerId,\r\n        bytes32 indexed requestId,\r\n        uint256 noRequests,\r\n        address clientAddress,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes parameters\r\n        );\r\n\r\n    event ClientRequestFulfilled(\r\n        bytes32 indexed providerId,\r\n        bytes32 indexed requestId,\r\n        uint256 statusCode,\r\n        bytes32 data\r\n        );\r\n\r\n    event ClientRequestFulfilledWithBytes(\r\n        bytes32 indexed providerId,\r\n        bytes32 indexed requestId,\r\n        uint256 statusCode,\r\n        bytes data\r\n        );\r\n\r\n    event ClientRequestFailed(\r\n        bytes32 indexed providerId,\r\n        bytes32 indexed requestId\r\n        );\r\n\r\n    function makeRequest(\r\n        bytes32 templateId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        returns (bytes32 requestId);\r\n\r\n    function makeShortRequest(\r\n        bytes32 templateId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        returns (bytes32 requestId);\r\n\r\n    function makeFullRequest(\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        returns (bytes32 requestId);\r\n\r\n    function fulfill(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        uint256 statusCode,\r\n        bytes32 data,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId\r\n        )\r\n        external\r\n        returns(\r\n            bool callSuccess,\r\n            bytes memory callData\r\n        );\r\n\r\n    function fulfillBytes(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        uint256 statusCode,\r\n        bytes calldata data,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId\r\n        )\r\n        external\r\n        returns(\r\n            bool callSuccess,\r\n            bytes memory callData\r\n        );\r\n\r\n    function fail(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId\r\n        )\r\n        external;\r\n}\r\n"
    },
    "contracts/EndpointStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./interfaces/IEndpointStore.sol\";\r\nimport \"./ProviderStore.sol\";\r\n\r\n\r\n/// @title The contract where the endpoints are stored\r\n/// @notice This contract is used by the provider admin to associate their\r\n/// endpoints with authorization policies, which both the oracle node and the\r\n/// requester can check to verify authorization.\r\ncontract EndpointStore is ProviderStore, IEndpointStore {\r\n    mapping(bytes32 => mapping(bytes32 => address[])) private providerIdToEndpointIdToAuthorizers;\r\n\r\n\r\n    /// @notice Updates the endpoint authorizers of a provider\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param endpointId Endpoint ID\r\n    /// @param authorizers Authorizer contract addresses\r\n    function updateEndpointAuthorizers(\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        address[] calldata authorizers\r\n        )\r\n        external\r\n        override\r\n        onlyProviderAdmin(providerId)\r\n    {\r\n        providerIdToEndpointIdToAuthorizers[providerId][endpointId] = authorizers;\r\n        emit EndpointUpdated(\r\n            providerId,\r\n            endpointId,\r\n            authorizers\r\n            );\r\n    }\r\n\r\n    /// @notice Retrieves the endpoint parameters addressed by the ID\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param endpointId Endpoint ID\r\n    /// @return authorizers Authorizer contract addresses\r\n    function getEndpointAuthorizers(\r\n        bytes32 providerId,\r\n        bytes32 endpointId\r\n        )\r\n        external\r\n        view\r\n        override\r\n        returns(address[] memory authorizers)\r\n    {\r\n        authorizers = providerIdToEndpointIdToAuthorizers[providerId][endpointId];\r\n    }\r\n}\r\n"
    },
    "contracts/TemplateStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./interfaces/ITemplateStore.sol\";\r\n\r\n\r\n/// @title The contract where request templates are stored\r\n/// @notice Most requests are repeated many times with the same parameters.\r\n/// This contract allows the requester to announce their parameters once, then\r\n/// refer to that announcement when they are making a request, instead of\r\n/// passing the same parameters repeatedly.\r\n/// @dev A template is composed of two groups of parameters. The first group is\r\n/// requester-agnostic (providerId, endpointInd, parameters), while the second\r\n/// group is requester-specific (requesterIndex, designatedWallet, fulfillAddress,\r\n/// fulfillFunctionId). Short requests refer to a template and use both of\r\n/// these groups of parameters. Regular requests refer to a template, but only\r\n/// use the requester-agnostic parameters of it, and require the client to\r\n/// provide the requester-specific parameters. In addition, both regular and\r\n/// short requests can overwrite parameters encoded in the parameters field of\r\n/// the template at request-time. See Airnode.sol for more information\r\n/// (specifically makeShortRequest() and makeRequest()).\r\ncontract TemplateStore is ITemplateStore {\r\n    struct Template {\r\n        bytes32 providerId;\r\n        bytes32 endpointId;\r\n        uint256 requesterIndex;\r\n        address designatedWallet;\r\n        address fulfillAddress;\r\n        bytes4 fulfillFunctionId;\r\n        bytes parameters;\r\n        }\r\n\r\n    mapping(bytes32 => Template) internal templates;\r\n\r\n\r\n    /// @notice Creates a request template with the given parameters,\r\n    /// addressable by the ID it returns\r\n    /// @dev A specific set of request parameters will always have\r\n    /// the same ID. This means a few things: (1) You can compute the expected\r\n    /// ID of a set of parameters off-chain, (2) creating a new template with\r\n    /// the same parameters will overwrite the old one and return the same\r\n    /// template ID, (3) after you query a template with its ID, you can verify\r\n    /// its integrity by applying the hash and comparing the result with the\r\n    /// ID.\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param endpointId Endpoint ID from EndpointStore\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet that is requested to fulfill\r\n    /// the request\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @param parameters Static request parameters (i.e., parameters that will\r\n    /// not change between requests, unlike the dynamic parameters determined\r\n    /// at runtime)\r\n    /// @return templateId Request template ID\r\n    function createTemplate(\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        override\r\n        returns (bytes32 templateId)\r\n    {\r\n        templateId = keccak256(abi.encode(\r\n            providerId,\r\n            endpointId,\r\n            requesterIndex,\r\n            designatedWallet,\r\n            fulfillAddress,\r\n            fulfillFunctionId,\r\n            parameters\r\n            ));\r\n        templates[templateId] = Template({\r\n            providerId: providerId,\r\n            endpointId: endpointId,\r\n            requesterIndex: requesterIndex,\r\n            designatedWallet: designatedWallet,\r\n            fulfillAddress: fulfillAddress,\r\n            fulfillFunctionId: fulfillFunctionId,\r\n            parameters: parameters\r\n        });\r\n        emit TemplateCreated(\r\n          templateId,\r\n          providerId,\r\n          endpointId,\r\n          requesterIndex,\r\n          designatedWallet,\r\n          fulfillAddress,\r\n          fulfillFunctionId,\r\n          parameters\r\n          );\r\n    }\r\n\r\n    /// @notice Retrieves request parameters addressed by the ID\r\n    /// @param templateId Request template ID\r\n    /// @return providerId Provider ID from ProviderStore\r\n    /// @return endpointId Endpoint ID from EndpointStore\r\n    /// @return requesterIndex Requester index from RequesterStore\r\n    /// @return designatedWallet Designated wallet that is requested to fulfill\r\n    /// the request\r\n    /// @return fulfillAddress Address that will be called to fulfill\r\n    /// @return fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @return parameters Static request parameters (i.e., parameters that will\r\n    /// not change between requests, unlike the dynamic parameters determined\r\n    /// at runtime)\r\n    function getTemplate(bytes32 templateId)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bytes32 providerId,\r\n            bytes32 endpointId,\r\n            uint256 requesterIndex,\r\n            address designatedWallet,\r\n            address fulfillAddress,\r\n            bytes4 fulfillFunctionId,\r\n            bytes memory parameters\r\n        )\r\n    {\r\n        providerId = templates[templateId].providerId;\r\n        endpointId = templates[templateId].endpointId;\r\n        requesterIndex = templates[templateId].requesterIndex;\r\n        designatedWallet = templates[templateId].designatedWallet;\r\n        fulfillAddress = templates[templateId].fulfillAddress;\r\n        fulfillFunctionId = templates[templateId].fulfillFunctionId;\r\n        parameters = templates[templateId].parameters;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IEndpointStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IProviderStore.sol\";\r\n\r\n\r\ninterface IEndpointStore is IProviderStore {\r\n    event EndpointUpdated(\r\n        bytes32 indexed providerId,\r\n        bytes32 indexed endpointId,\r\n        address[] authorizers\r\n        );\r\n\r\n    function updateEndpointAuthorizers(\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        address[] calldata authorizers\r\n        )\r\n        external;\r\n\r\n    function getEndpointAuthorizers(\r\n        bytes32 providerId,\r\n        bytes32 endpointId\r\n        )\r\n        external\r\n        view\r\n        returns(address[] memory authorizers);\r\n}\r\n"
    },
    "contracts/interfaces/ITemplateStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface ITemplateStore {\r\n    event TemplateCreated(\r\n        bytes32 indexed templateId,\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes parameters\r\n        );\r\n\r\n    function createTemplate(\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n        returns (bytes32 templateId);\r\n\r\n    function getTemplate(bytes32 templateId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 providerId,\r\n            bytes32 endpointId,\r\n            uint256 requesterIndex,\r\n            address designatedWallet,\r\n            address fulfillAddress,\r\n            bytes4 fulfillFunctionId,\r\n            bytes memory parameters\r\n        );\r\n}\r\n"
    },
    "contracts/interfaces/IProviderStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IRequesterStore.sol\";\r\n\r\n\r\ninterface IProviderStore is IRequesterStore {\r\n    event ProviderCreated(\r\n        bytes32 indexed providerId,\r\n        address admin,\r\n        string xpub\r\n        );\r\n\r\n    event ProviderUpdated(\r\n        bytes32 indexed providerId,\r\n        address admin\r\n        );\r\n\r\n    event WithdrawalRequested(\r\n        bytes32 indexed providerId,\r\n        uint256 indexed requesterIndex,\r\n        bytes32 indexed withdrawalRequestId,\r\n        address designatedWallet,\r\n        address destination\r\n        );\r\n\r\n    event WithdrawalFulfilled(\r\n        bytes32 indexed providerId,\r\n        uint256 indexed requesterIndex,\r\n        bytes32 indexed withdrawalRequestId,\r\n        address designatedWallet,\r\n        address destination,\r\n        uint256 amount\r\n        );\r\n\r\n    function createProvider(\r\n        address admin,\r\n        string calldata xpub\r\n        )\r\n        external\r\n        payable\r\n        returns (bytes32 providerId);\r\n\r\n    function updateProvider(\r\n        bytes32 providerId,\r\n        address admin\r\n        )\r\n        external;\r\n\r\n    function requestWithdrawal(\r\n        bytes32 providerId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address destination\r\n    )\r\n        external;\r\n\r\n    function fulfillWithdrawal(\r\n        bytes32 withdrawalRequestId,\r\n        bytes32 providerId,\r\n        uint256 requesterIndex,\r\n        address destination\r\n        )\r\n        external\r\n        payable;\r\n\r\n    function getProvider(bytes32 providerId)\r\n        external\r\n        view\r\n        returns (\r\n            address admin,\r\n            string memory xpub\r\n        );\r\n}\r\n"
    },
    "contracts/interfaces/IRequesterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IRequesterStore {\r\n    event RequesterCreated(\r\n        uint256 indexed requesterIndex,\r\n        address admin\r\n        );\r\n\r\n    event RequesterUpdated(\r\n        uint256 indexed requesterIndex,\r\n        address admin\r\n        );\r\n\r\n    event ClientEndorsementStatusUpdated(\r\n        uint256 indexed requesterIndex,\r\n        address indexed clientAddress,\r\n        bool endorsementStatus\r\n        );\r\n\r\n    function createRequester(address admin)\r\n        external\r\n        returns (uint256 requesterIndex);\r\n\r\n    function updateRequesterAdmin(\r\n        uint256 requesterIndex,\r\n        address admin\r\n        )\r\n        external;\r\n\r\n    function updateClientEndorsementStatus(\r\n        uint256 requesterIndex,\r\n        address clientAddress,\r\n        bool endorsementStatus\r\n        )\r\n        external;\r\n}\r\n"
    },
    "contracts/ProviderStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./interfaces/IProviderStore.sol\";\r\nimport \"./RequesterStore.sol\";\r\n\r\n\r\n/// @title The contract where the providers are stored\r\ncontract ProviderStore is RequesterStore, IProviderStore {\r\n    struct Provider {\r\n        address admin;\r\n        string xpub;\r\n        }\r\n\r\n    mapping(bytes32 => Provider) internal providers;\r\n    mapping(bytes32 => bytes32) private withdrawalRequestIdToParameters;\r\n\r\n\r\n    /// @notice Allows the master wallet (m) of the provider to create a\r\n    /// provider record on this chain\r\n    /// @dev The oracle node should calculate their providerId off-chain and\r\n    /// retrieve its details with a getProvider() call. If the xpub is does not\r\n    /// match, it should call this method to update the provider record.\r\n    /// Note that the provider private key can be used to update admin through\r\n    /// this method. This is allowed on purpose, as the provider private key is\r\n    /// more privileged than the provider admin account.\r\n    /// @param admin Provider admin\r\n    /// @param xpub Master public key of the provider node\r\n    /// @return providerId Provider ID\r\n    function createProvider(\r\n        address admin,\r\n        string calldata xpub\r\n        )\r\n        external\r\n        payable\r\n        override\r\n        returns (bytes32 providerId)\r\n    {\r\n        providerId = keccak256(abi.encode(msg.sender));\r\n        providers[providerId] = Provider({\r\n            admin: admin,\r\n            xpub: xpub\r\n            });\r\n        emit ProviderCreated(\r\n            providerId,\r\n            admin,\r\n            xpub\r\n            );\r\n        if (msg.value > 0)\r\n        {\r\n            (bool success, ) = admin.call{ value: msg.value }(\"\");  // solhint-disable-line\r\n            require(success, \"Transfer failed\");\r\n        }\r\n    }\r\n\r\n    /// @notice Updates the provider\r\n    /// @param providerId Provider ID\r\n    /// @param admin Provider admin\r\n    function updateProvider(\r\n        bytes32 providerId,\r\n        address admin\r\n        )\r\n        external\r\n        override\r\n        onlyProviderAdmin(providerId)\r\n    {\r\n        providers[providerId].admin = admin;\r\n        emit ProviderUpdated(\r\n            providerId,\r\n            admin\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the requester admin to create a request for the\r\n    /// provider to send the funds kept in their designated wallet to\r\n    /// destination\r\n    /// @dev We do not need to use the withdrawal request parameters in the\r\n    /// request ID hash to validate them at the node side because all of the\r\n    /// parameters are used during fulfillment and will get validated on-chain.\r\n    /// @param providerId Provider ID\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet that the withdrawal is\r\n    /// requested from\r\n    /// @param destination Withdrawal destination\r\n    function requestWithdrawal(\r\n        bytes32 providerId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address destination\r\n    )\r\n        external\r\n        override\r\n        onlyRequesterAdmin(requesterIndex)\r\n    {\r\n        bytes32 withdrawalRequestId = keccak256(abi.encodePacked(\r\n            requesterIndexToNoWithdrawalRequests[requesterIndex]++,\r\n            requesterIndex,\r\n            this\r\n            ));\r\n        bytes32 withdrawalParameters = keccak256(abi.encodePacked(\r\n            providerId,\r\n            requesterIndex,\r\n            designatedWallet,\r\n            destination\r\n            ));\r\n        withdrawalRequestIdToParameters[withdrawalRequestId] = withdrawalParameters;\r\n        emit WithdrawalRequested(\r\n            providerId,\r\n            requesterIndex,\r\n            withdrawalRequestId,\r\n            designatedWallet,\r\n            destination\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the designated wallet to fulfill the withdrawal\r\n    /// request made by the requester\r\n    /// @dev The oracle node sends the funds through this method to emit an\r\n    /// event that indicates that the withdrawal request has been fulfilled\r\n    /// @param providerId Provider ID\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param destination Withdrawal destination\r\n    function fulfillWithdrawal(\r\n        bytes32 withdrawalRequestId,\r\n        bytes32 providerId,\r\n        uint256 requesterIndex,\r\n        address destination\r\n        )\r\n        external\r\n        payable\r\n        override\r\n    {\r\n        bytes32 withdrawalParameters = keccak256(abi.encodePacked(\r\n            providerId,\r\n            requesterIndex,\r\n            msg.sender,\r\n            destination\r\n            ));\r\n        require(\r\n            withdrawalRequestIdToParameters[withdrawalRequestId] == withdrawalParameters,\r\n            \"No such withdrawal request\"\r\n            );\r\n        delete withdrawalRequestIdToParameters[withdrawalRequestId];\r\n        emit WithdrawalFulfilled(\r\n            providerId,\r\n            requesterIndex,\r\n            withdrawalRequestId,\r\n            msg.sender,\r\n            destination,\r\n            msg.value\r\n            );\r\n        (bool success, ) = destination.call{ value: msg.value }(\"\");  // solhint-disable-line\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    /// @notice Retrieves provider parameters addressed by the ID\r\n    /// @param providerId Provider ID\r\n    /// @return admin Provider admin\r\n    /// @return xpub Master public key of the provider node\r\n    function getProvider(bytes32 providerId)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            address admin,\r\n            string memory xpub\r\n        )\r\n    {\r\n        admin = providers[providerId].admin;\r\n        xpub = providers[providerId].xpub;\r\n    }\r\n\r\n    /// @dev Reverts if the caller is not the provider admin\r\n    /// @param providerId Provider ID\r\n    modifier onlyProviderAdmin(bytes32 providerId)\r\n    {\r\n        require(\r\n            msg.sender == providers[providerId].admin,\r\n            \"Caller is not provider admin\"\r\n            );\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/RequesterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./interfaces/IRequesterStore.sol\";\r\n\r\n\r\n/// @title The contract where the requesters are stored\r\n/// @notice This contract is used by requesters to manage their endorsemenets.\r\n/// A requester endorsing a client means that the client can request their\r\n/// requests to be fulfilled by the respective requester's designated wallets.\r\ncontract RequesterStore is IRequesterStore {\r\n    mapping(uint256 => address) public requesterIndexToAdmin;\r\n    mapping(uint256 => mapping(address => bool)) public requesterIndexToClientAddressToEndorsementStatus;\r\n    mapping(address => uint256) public clientAddressToNoRequests;\r\n    mapping(uint256 => uint256) public requesterIndexToNoWithdrawalRequests;\r\n    uint256 private noRequesters = 1;\r\n\r\n\r\n    /// @notice Creates a requester with the given parameters, addressable by\r\n    /// the index it returns\r\n    /// @param admin Requester admin\r\n    /// @return requesterIndex Requester index\r\n    function createRequester(address admin)\r\n        external\r\n        override\r\n        returns (uint256 requesterIndex)\r\n    {\r\n        requesterIndex = noRequesters++;\r\n        requesterIndexToAdmin[requesterIndex] = admin;\r\n        // Initialize the requester nonce during creation for consistent\r\n        // withdrawal request gas cost\r\n        requesterIndexToNoWithdrawalRequests[requesterIndex] = 1;\r\n        emit RequesterCreated(\r\n            requesterIndex,\r\n            admin\r\n            );\r\n    }\r\n\r\n    /// @notice Updates the requester admin\r\n    /// @param requesterIndex Requester index\r\n    /// @param admin Requester admin\r\n    function updateRequesterAdmin(\r\n        uint256 requesterIndex,\r\n        address admin\r\n        )\r\n        external\r\n        override\r\n        onlyRequesterAdmin(requesterIndex)\r\n    {\r\n        requesterIndexToAdmin[requesterIndex] = admin;\r\n        emit RequesterUpdated(\r\n            requesterIndex,\r\n            admin\r\n            );\r\n    }\r\n\r\n    /// @notice Called by the requester admin to endorse a client, i.e., allow\r\n    /// a client to use its designated wallets\r\n    /// @dev This is not provider specific, i.e., the requester allows the\r\n    /// client's requests to be fulfilled through its designated wallets across\r\n    /// all providers\r\n    /// @param requesterIndex Requester index\r\n    /// @param clientAddress Client address\r\n    function updateClientEndorsementStatus(\r\n        uint256 requesterIndex,\r\n        address clientAddress,\r\n        bool endorsementStatus\r\n        )\r\n        external\r\n        override\r\n        onlyRequesterAdmin(requesterIndex)\r\n    {\r\n        // Initialize the client nonce if it is being endorsed for the first\r\n        // time for consistent request gas cost\r\n        if (endorsementStatus && clientAddressToNoRequests[clientAddress] == 0)\r\n        {\r\n            clientAddressToNoRequests[clientAddress] = 1;\r\n        }\r\n        requesterIndexToClientAddressToEndorsementStatus[requesterIndex][clientAddress] = endorsementStatus;\r\n        emit ClientEndorsementStatusUpdated(\r\n            requesterIndex,\r\n            clientAddress,\r\n            endorsementStatus\r\n            );\r\n    }\r\n\r\n    /// @dev Reverts if the caller is not the requester admin\r\n    /// @param requesterIndex Requester index\r\n    modifier onlyRequesterAdmin(uint256 requesterIndex)\r\n    {\r\n        require(\r\n            msg.sender == requesterIndexToAdmin[requesterIndex],\r\n            \"Caller is not requester admin\"\r\n            );\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IConvenience.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./IAirnode.sol\";\r\n\r\n\r\ninterface IConvenience {\r\n    function getProviderAndBlockNumber(bytes32 providerId)\r\n        external\r\n        view\r\n        returns (\r\n            address admin,\r\n            string memory xpub,\r\n            uint256 blockNumber\r\n        );\r\n\r\n    function getTemplates(bytes32[] calldata templateIds)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32[] memory providerIds,\r\n            bytes32[] memory endpointIds,\r\n            uint256[] memory requesterIndices,\r\n            address[] memory designatedWallets,\r\n            address[] memory fulfillAddresses,\r\n            bytes4[] memory fulfillFunctionIds,\r\n            bytes[] memory parameters\r\n        );\r\n\r\n    function checkAuthorizationStatus(\r\n        bytes32 providerId,\r\n        bytes32 requestId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address clientAddress\r\n        )\r\n        external\r\n        view\r\n        returns(bool status);\r\n\r\n    function checkAuthorizationStatuses(\r\n        bytes32 providerId,\r\n        bytes32[] calldata requestIds, \r\n        bytes32[] calldata endpointIds,\r\n        uint256[] calldata requesterIndices,\r\n        address[] calldata designatedWallets,\r\n        address[] calldata clientAddresses\r\n        )\r\n        external\r\n        view\r\n        returns (bool[] memory statuses);\r\n}\r\n"
    },
    "contracts/Convenience.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./interfaces/IConvenience.sol\";\r\nimport \"./authorizers/interfaces/IAuthorizer.sol\";\r\nimport \"./interfaces/IAirnode.sol\";\r\n\r\n\r\ncontract Convenience is IConvenience {\r\n    IAirnode public airnode;\r\n\r\n\r\n    constructor (address _airnode)\r\n        public\r\n    {\r\n        airnode = IAirnode(_airnode);\r\n    }\r\n\r\n    /// @notice A convenience function to retrieve provider parameters and the\r\n    /// block number with a single call\r\n    /// @param providerId Provider ID\r\n    /// @return admin Provider admin\r\n    /// @return xpub Master public key of the provider node\r\n    /// @return blockNumber Block number\r\n    function getProviderAndBlockNumber(bytes32 providerId)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            address admin,\r\n            string memory xpub,\r\n            uint256 blockNumber\r\n        )\r\n    {\r\n        (admin, xpub) = airnode.getProvider(providerId);\r\n        blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice A convenience function to retrieve multiple templates with a\r\n    /// single call\r\n    /// @param templateIds Request template IDs\r\n    /// @return providerIds Provider IDs from ProviderStore\r\n    /// @return endpointIds Endpoint IDs from EndpointStore\r\n    /// @return requesterIndices Requester indices from RequesterStore\r\n    /// @return designatedWallets Designated wallets that are requested to\r\n    /// fulfill the request\r\n    /// @return fulfillAddresses Addresses that will be called to fulfill\r\n    /// @return fulfillFunctionIds Signatures of the functions that will be\r\n    /// called to fulfill\r\n    /// @return parameters Array of static request parameters (i.e., parameters\r\n    /// that will not change between requests, unlike the dynamic parameters\r\n    /// determined at runtime)\r\n    function getTemplates(bytes32[] calldata templateIds)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bytes32[] memory providerIds,\r\n            bytes32[] memory endpointIds,\r\n            uint256[] memory requesterIndices,\r\n            address[] memory designatedWallets,\r\n            address[] memory fulfillAddresses,\r\n            bytes4[] memory fulfillFunctionIds,\r\n            bytes[] memory parameters\r\n        )\r\n    {\r\n        providerIds = new bytes32[](templateIds.length);\r\n        endpointIds = new bytes32[](templateIds.length);\r\n        requesterIndices = new uint256[](templateIds.length);\r\n        designatedWallets = new address[](templateIds.length);\r\n        fulfillAddresses = new address[](templateIds.length);\r\n        fulfillFunctionIds = new bytes4[](templateIds.length);\r\n        parameters = new bytes[](templateIds.length);\r\n        for (uint256 ind = 0; ind < templateIds.length; ind++)\r\n        {\r\n            (\r\n                providerIds[ind],\r\n                endpointIds[ind],\r\n                requesterIndices[ind],\r\n                designatedWallets[ind],\r\n                fulfillAddresses[ind],\r\n                fulfillFunctionIds[ind],\r\n                parameters[ind]\r\n                ) = airnode.getTemplate(templateIds[ind]);\r\n        }\r\n    }\r\n\r\n    /// @notice Uses the authorizer contracts of an endpoint of a provider to\r\n    /// decide if a client contract is authorized to call the endpoint. Once an\r\n    /// oracle node receives a request, it calls this method to determine if it\r\n    /// should respond. Similarly, third parties can use this method to\r\n    /// determine if a client contract is authorized to call an endpoint.\r\n    /// @dev Authorizer contracts are not trusted, so this method should only\r\n    /// be called off-chain.\r\n    /// The elements of the authorizer array are either addresses of Authorizer\r\n    /// contracts with the interface defined in IAuthorizer or 0.\r\n    /// Say we have authorizer contracts X, Y, Z, T, and our authorizer\r\n    /// array is [X, Y, 0, Z, T]. This means that the requester should satisfy\r\n    /// (X AND Y) OR (Z AND T) to be considered authorized. In other words,\r\n    /// consequent authorizer contracts need to verify authorization\r\n    /// simultaneously, while 0 represents the start of an independent\r\n    /// authorization policy. From a logical standpoint, consequent authorizers\r\n    /// get ANDed while 0 acts as an OR gate, providing great flexibility in\r\n    /// forming an authorization policy out of simple building blocks. We could\r\n    /// also define a NOT gate here to achieve a full set of universal logic\r\n    /// gates, but that does not make much sense in this context because\r\n    /// authorizers tend to check for positive conditions (have paid, is\r\n    /// whitelisted, etc.) and we would not need policies that require these to\r\n    /// be false.\r\n    /// Note that authorizers should not start or end with 0, and 0s should\r\n    /// not be used consecutively (e.g., [X, Y, 0, 0, Z, T]).\r\n    /// [] returns false (deny everyone), [0] returns true (accept everyone).\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param requestId Request ID\r\n    /// @param endpointId Endpoint ID from EndpointStore\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet\r\n    /// @param clientAddress Client address\r\n    /// @return status Authorization status of the request\r\n    function checkAuthorizationStatus(\r\n        bytes32 providerId,\r\n        bytes32 requestId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address clientAddress\r\n        )\r\n        public\r\n        view\r\n        override\r\n        returns(bool status)\r\n    {\r\n        address[] memory authorizers = airnode.getEndpointAuthorizers(providerId, endpointId);  \r\n        uint256 noAuthorizers = authorizers.length;\r\n        // If no authorizers have been set, deny access by default\r\n        if (noAuthorizers == 0)\r\n        {\r\n            return false;\r\n        }\r\n        // authorizedByAll will remain true as long as none of the authorizers\r\n        // in a group reports that the client is unauthorized\r\n        bool authorizedByAll = true;\r\n        for (uint256 ind = 0; ind < noAuthorizers; ind++)\r\n        {\r\n            address authorizerAddress = authorizers[ind];\r\n            if (authorizerAddress == address(0)) {\r\n                // If we have reached a 0 without getting any unauthorized\r\n                // reports, we can return true\r\n                if (authorizedByAll) {\r\n                    return true;\r\n                }\r\n                // Otherwise, reset authorizedByAll and start checking the next\r\n                // group\r\n                authorizedByAll = true;\r\n            }\r\n            // We only need to check the next authorizer if we have a good track\r\n            // record for this group\r\n            else if (authorizedByAll) {\r\n                IAuthorizer authorizer = IAuthorizer(authorizerAddress);\r\n                // Set authorizedByAll to false if we got an unauthorized report.\r\n                // This means that we will not be able to return a true from\r\n                // this group of authorizers.\r\n                if (!authorizer.checkIfAuthorized(\r\n                    requestId, providerId, endpointId, requesterIndex, designatedWallet, clientAddress\r\n                    )) {\r\n                    authorizedByAll = false;\r\n                }\r\n            }\r\n        }\r\n        // Finally, if we have reached the end of the authorizers (i.e., we\r\n        // are at the last element of the last group), just return the current\r\n        // authorizedByAll, which will only be true if all authorizers from the\r\n        // last group have returned true.\r\n        return authorizedByAll;\r\n    }\r\n\r\n    /// @notice A convenience function to make multiple authorization status\r\n    /// checks with a single call\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param requestIds Request IDs\r\n    /// @param endpointIds Endpoint IDs from EndpointStore\r\n    /// @param requesterIndices Requester indices from RequesterStore\r\n    /// @param designatedWallets Designated wallets\r\n    /// @param clientAddresses Client addresses\r\n    /// @return statuses Authorization statuses of the request\r\n    function checkAuthorizationStatuses(\r\n        bytes32 providerId,\r\n        bytes32[] calldata requestIds,\r\n        bytes32[] calldata endpointIds,\r\n        uint256[] calldata requesterIndices,\r\n        address[] calldata designatedWallets,\r\n        address[] calldata clientAddresses\r\n        )\r\n        external\r\n        view\r\n        override\r\n        returns (bool[] memory statuses)\r\n    {\r\n        require(\r\n            requestIds.length == endpointIds.length\r\n                && requestIds.length == requesterIndices.length\r\n                && requestIds.length == designatedWallets.length\r\n                && requestIds.length == clientAddresses.length,\r\n            \"Parameter lengths must be equal\"\r\n        );\r\n        statuses = new bool[](requestIds.length);\r\n        for (uint256 ind = 0; ind < requestIds.length; ind++)\r\n        {\r\n            statuses[ind] = checkAuthorizationStatus(\r\n                providerId,\r\n                requestIds[ind],\r\n                endpointIds[ind],\r\n                requesterIndices[ind],\r\n                designatedWallets[ind],\r\n                clientAddresses[ind]\r\n                );\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/authorizers/interfaces/IAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IAuthorizer {\r\n    function checkIfAuthorized(\r\n        bytes32 requestId,\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address clientAddress\r\n        )\r\n        external\r\n        view\r\n        returns (bool status);\r\n}\r\n"
    },
    "contracts/authorizers/interfaces/IMinBalanceAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IAuthorizer.sol\";\r\n\r\n\r\ninterface IMinBalanceAuthorizer is IAuthorizer {\r\n    event MinBalanceUpdated(\r\n        bytes32 indexed providerId,\r\n        uint256 minBalance\r\n        );\r\n\r\n    function updateMinBalance(\r\n        bytes32 providerId,\r\n        uint256 minBalance\r\n        )\r\n        external;\r\n}\r\n"
    },
    "contracts/authorizers/MinBalanceAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./interfaces/IMinBalanceAuthorizer.sol\";\r\nimport \"../interfaces/IAirnode.sol\";\r\n\r\n\r\n/// @title The authorizer contract that checks if the designated wallet to be\r\n/// used to fulfill a request has more than minBalance\r\n/// @dev Airnode will first make an API call, then attempt to fulfill the\r\n/// respective request. This means that if the designatedWallet that will\r\n/// fulfill the request does not have enough funds, the API call will have been\r\n/// made for nothing, and this will be repeated until the request leaves the\r\n/// scope of the node. By using this authorizer and setting a minBalance (e.g.,\r\n/// 0.1 ETH), the provider can choose to ignore requests that will be fulfilled\r\n/// by designatedWallets with balances less than minBalance.\r\ncontract MinBalanceAuthorizer is IMinBalanceAuthorizer {\r\n    IAirnode public airnode;\r\n    uint256 public immutable authorizerType = 1;\r\n    mapping(bytes32 => uint256) private providerIdToMinBalance;\r\n\r\n\r\n    /// @param _airnode Address of the Airnode contract\r\n    constructor (address _airnode)\r\n        public\r\n    {\r\n        airnode = IAirnode(_airnode);\r\n    }\r\n\r\n    /// @notice Updates the provider-specific minBalance\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param minBalance The minimum balance a designatedWallet has to have\r\n    /// for the provider to process requests that will be fulfilled by that\r\n    /// designatedWallet\r\n    function updateMinBalance(\r\n        bytes32 providerId,\r\n        uint256 minBalance\r\n        )\r\n        external\r\n        override\r\n    {\r\n        (address admin, string memory xpub) = airnode.getProvider(providerId);  // solhint-disable-line\r\n        require(msg.sender == admin, \"Caller is not provider admin\");\r\n        providerIdToMinBalance[providerId] = minBalance;\r\n        emit MinBalanceUpdated(providerId, minBalance);\r\n    }\r\n\r\n    /// @notice Verifies the authorization status of a request according to\r\n    /// the balance of designatedWallet\r\n    /// @param requestId Request ID\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param endpointId Endpoint ID from EndpointStore\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet\r\n    /// @param clientAddress Client address\r\n    /// @return status Authorization status of the request\r\n    function checkIfAuthorized(\r\n        bytes32 requestId,    // solhint-disable-line\r\n        bytes32 providerId,\r\n        bytes32 endpointId,   // solhint-disable-line\r\n        uint256 requesterIndex, // solhint-disable-line\r\n        address designatedWallet,\r\n        address clientAddress // solhint-disable-line\r\n        )\r\n        virtual\r\n        external\r\n        view\r\n        override\r\n        returns (bool status)\r\n    {\r\n        return designatedWallet.balance >= providerIdToMinBalance[providerId];\r\n    }\r\n}\r\n"
    },
    "contracts/AirnodeClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"./interfaces/IAirnodeClient.sol\";\r\nimport \"./interfaces/IAirnode.sol\";\r\n\r\n\r\n/// @title The contract to be inherited from to use Airnode to make requests\r\ncontract AirnodeClient is IAirnodeClient {\r\n    IAirnode public airnode;\r\n\r\n    /// @dev Airnode address is set at deployment. If you need to be able to\r\n    /// update it, you will have to implement that functionality (and probably\r\n    /// put it behind onlyOwner).\r\n    /// @param airnodeAddress Airnode contract address\r\n    constructor (address airnodeAddress)\r\n        public\r\n    {\r\n        airnode = IAirnode(airnodeAddress);\r\n    }\r\n\r\n    /// @notice Returns the Airnode contract address used by this client\r\n    /// @return _airnodeAddress Airnode contract address\r\n    function airnodeAddress()\r\n        external\r\n        view\r\n        override\r\n        returns(address _airnodeAddress)\r\n    {\r\n        _airnodeAddress = address(airnode);\r\n    }\r\n\r\n    /// @dev Reverts if the caller is not the Airnode contract\r\n    /// Use it as a modifier for fulfill and error callback methods\r\n    modifier onlyAirnode()\r\n    {\r\n        require(\r\n            msg.sender == address(airnode),\r\n            \"Caller not the Airnode contract\"\r\n            );\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IAirnodeClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IAirnodeClient {\r\n  function airnodeAddress()\r\n      external\r\n      view\r\n      returns(address _airnodeAddress);\r\n}\r\n"
    },
    "contracts/mock/MockAirnodeClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nimport \"../AirnodeClient.sol\";\r\n\r\n\r\n/// @title A mock Airnode client contract\r\ncontract MockAirnodeClient is AirnodeClient {\r\n    event RequestFulfilled(\r\n        bytes32 requestId,\r\n        uint256 statusCode,\r\n        bytes32 data\r\n        );\r\n\r\n    event RequestFulfilledWithBytes(\r\n        bytes32 requestId,\r\n        uint256 statusCode,\r\n        bytes data\r\n        );\r\n\r\n    mapping(bytes32 => bool) private incomingFulfillments;\r\n\r\n    /// @param airnodeAddress Airnode contract address\r\n    constructor (address airnodeAddress)\r\n        public\r\n        AirnodeClient(airnodeAddress)\r\n    {}  // solhint-disable-line\r\n\r\n    /// @notice A wrapper for the respective method at Airnode.sol for testing\r\n    /// @param templateId Template ID from TemplateStore\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet that is requested to fulfill\r\n    /// the request\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\r\n    /// determined at runtime, unlike the static parameters stored in the\r\n    /// template)\r\n    function makeRequest(\r\n        bytes32 templateId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n    {\r\n        bytes32 requestId = airnode.makeRequest(\r\n            templateId,\r\n            requesterIndex,\r\n            designatedWallet,\r\n            fulfillAddress,\r\n            fulfillFunctionId,\r\n            parameters\r\n            );\r\n        incomingFulfillments[requestId] = true;\r\n    }\r\n\r\n    /// @notice A wrapper for the respective method at Airnode.sol for testing\r\n    /// @param templateId Template ID from TemplateStore\r\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\r\n    /// determined at runtime, unlike the static parameters stored in the\r\n    /// template)\r\n    function makeShortRequest(\r\n        bytes32 templateId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n    {\r\n        bytes32 requestId = airnode.makeShortRequest(\r\n            templateId,\r\n            parameters\r\n            );\r\n        incomingFulfillments[requestId] = true;\r\n    }\r\n\r\n    /// @notice A wrapper for the respective method at Airnode.sol for testing\r\n    /// @param providerId Provider ID from ProviderStore\r\n    /// @param endpointId Endpoint ID from EndpointStore\r\n    /// @param requesterIndex Requester index from RequesterStore\r\n    /// @param designatedWallet Designated wallet that is requested to fulfill\r\n    /// the request\r\n    /// @param fulfillAddress Address that will be called to fulfill\r\n    /// @param fulfillFunctionId Signature of the function that will be called\r\n    /// to fulfill\r\n    /// @param parameters All request parameters\r\n    function makeFullRequest(\r\n        bytes32 providerId,\r\n        bytes32 endpointId,\r\n        uint256 requesterIndex,\r\n        address designatedWallet,\r\n        address fulfillAddress,\r\n        bytes4 fulfillFunctionId,\r\n        bytes calldata parameters\r\n        )\r\n        external\r\n    {\r\n        bytes32 requestId = airnode.makeFullRequest(\r\n            providerId,\r\n            endpointId,\r\n            requesterIndex,\r\n            designatedWallet,\r\n            fulfillAddress,\r\n            fulfillFunctionId,\r\n            parameters\r\n            );\r\n        incomingFulfillments[requestId] = true;\r\n    }\r\n\r\n    /// @notice A method to be called back by the respective method at\r\n    /// Airnode.sol for testing\r\n    /// @param requestId Request ID\r\n    /// @param statusCode Status code returned by the provider\r\n    /// @param data Data returned by the provider\r\n    function fulfill(\r\n        bytes32 requestId,\r\n        uint256 statusCode,\r\n        bytes32 data\r\n        )\r\n        external\r\n        onlyAirnode()\r\n    {\r\n        require(incomingFulfillments[requestId], \"No such request made\");\r\n        delete incomingFulfillments[requestId];\r\n        emit RequestFulfilled(\r\n            requestId,\r\n            statusCode,\r\n            data\r\n            );\r\n    }\r\n\r\n    /// @notice A method to be called back by the respective method at\r\n    /// Airnode.sol for testing\r\n    /// @param requestId Request ID\r\n    /// @param statusCode Status code returned by the provider\r\n    /// @param data Data returned by the provider\r\n    function fulfillBytes(\r\n        bytes32 requestId,\r\n        uint256 statusCode,\r\n        bytes calldata data\r\n        )\r\n        external\r\n        onlyAirnode()\r\n    {\r\n        require(incomingFulfillments[requestId], \"No such request made\");\r\n        delete incomingFulfillments[requestId];\r\n        emit RequestFulfilledWithBytes(\r\n            requestId,\r\n            statusCode,\r\n            data\r\n            );\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}